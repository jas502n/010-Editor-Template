//------------------------------------------------
//--- 010 Editor v9.0 Binary Template
//
//      File: CSharp.bt
//   Authors: Tim Evans
//   Version: 1.0
//   Purpose: Syntax highlighting for C# files.
//  Category: Syntax
// File Mask: *.cs
//  ID Bytes: 
//   History: 
//   1.0   2019-05-26 Tim Evans: Initial version.
//------------------------------------------------
RequiresVersion( 9 );

// To save memory, allow a single copy of this template to provide 
//  syntax highlighting for all open files that match the file mask.
HighlightAllowInstanceSharing( true );

// Get list of coloring styles
local int commentStyle  = HighlightFindStyle( "code-comment" );
local int keywordStyle  = HighlightFindStyle( "code-keyword" );
local int dataTypeStyle = HighlightFindStyle( "code-data-type" );
local int stringStyle   = HighlightFindStyle( "code-string" );

// Types of rules we may be applying that may span multiple lines
const int RULE_NONE              = 0;
const int RULE_MULTILINE_COMMENT = 1;
const int RULE_STRING            = 2;

// Build list of keywords
local TKeywordList keywordList = HighlightBuildKeywordList( HIGHLIGHT_WHOLEWORD | HIGHLIGHT_IGNORECASE,
   "abstract", "as", "base", "break", "case", "catch", "checked", "class", "const", "continue",
   "default", "delegate", "do", "else", "enum", "event", "explicit", "extern", "false", "finally",
   "fixed", "for", "foreach", "goto", "if", "implicit", "in",  "interface", "internal", "is", 
   "lock", "namespace", "new", "null", "operator", "out", "override", "params", "private", "protected",
   "public", "readonly", "ref", "return", "sealed", "sizeof", "stackalloc", "static", "struct", 
   "switch", "this", "throw", "true", "try", "typeof", "unchecked", "unsafe", "using", "using", 
   "virtual", "void", "volatile", "while", "add", "alias", "ascending", "async", "await", "by",
   "descending", "dynamic", "equals", "from", "get", "global", "group", "into", "join", "let",
   "nameof", "on", "orderby", "partial", "remove", "select", "set", "value", "var", "when", "where", "yield"
 );
 
// Build list of datatypes
local TKeywordList dataTypeList = HighlightBuildKeywordList( HIGHLIGHT_WHOLEWORD | HIGHLIGHT_IGNORECASE,
   "bool", "byte", "char", "decimal", "double", "float", "int", "long", "object", "sbyte", 
   "short", "string", "uint", "ulong", "ushort" );

// Main function to apply syntax highlighting to a line of text.
//  flags is preserved between lines and allows us to do multi-line comments.
void HighlightLineRealtime( int64 line, wchar_t text[], int foreColors[], int backColors[], int count, ushort &flags )
{
    int i, len, pos, rule = flags;
    while( i < count )
    {  
        // Check multi-line comment - could be continued from a previous line
        if( (text[i] == '/' || rule == RULE_MULTILINE_COMMENT) && 
            HighlightCheckMultiLineRule( text, count, "/*", "*/", i, 
            rule, RULE_NONE, RULE_MULTILINE_COMMENT, foreColors, backColors, commentStyle ) ) 
            continue;

        // Check single-line comments
        if( (text[i] == '/') &&
            HighlightCheckCommentRule( text, count, "//", i, 
            foreColors, backColors, commentStyle ) ) 
            continue;

        // Check single-line strings
        if( (text[i] == '\"') && 
            HighlightCheckSingleLineRule( text, count, "\"", "\"", i, 
            foreColors, backColors, stringStyle, HIGHLIGHT_CSTRING ) ) 
            continue;

        // Check character constant
        if( (text[i] == '\'') &&
            HighlightCheckSingleLineRule( text, count, "\'", "\'", i, 
            foreColors, backColors, stringStyle, HIGHLIGHT_CSTRING ) ) 
            continue;

        // Check regular keywords
        if( HighlightCheckKeywordRule( text, count, keywordList, i, 
            foreColors, backColors, keywordStyle ) )
            continue;

        // Check data types
        if( HighlightCheckKeywordRule( text, count, dataTypeList, i, 
            foreColors, backColors, dataTypeStyle ) )
            continue;
    
        // Nothing found - skip over whole words
        i = HighlightGetNextToken( text, count, i );
    }

    // Save rule in the flags for the next line
    flags = rule;
}